library ieee;
use ieee.std_logic_1164.all;

entity ice_proc is
  generic (data_width  : positive := 16;
           instr_width : positive := 24;
           addr_width  : positive := 12);
  port (clk      : in  std_logic;
        clk90    : in  std_logic;
        reset    : in  std_logic;
        pc       : out std_logic_vector(11 downto 0);
        io_addr  : out std_logic_vector(11 downto 0);
        io_din   : in  std_logic_vector(data_width-1 downto 0);
        io_dout  : out std_logic_vector(data_width-1 downto 0);
        io_rd    : out std_logic;
        io_wr    : out std_logic);
end ice_proc;


architecture behaviour of ice_proc is

  -- instruction memory

  signal imem_instr : std_logic_vector(instr_width-1 downto 0);


  -- data memory
 
  signal dmem_addr : std_logic_vector(addr_width-1 downto 0);
  signal dmem_dout : std_logic_vector(data_width-1 downto 0);

  
  -- register file 
  
  signal rf_rp0_data     : std_logic_vector(data_width-1 downto 0);
  signal rf_rp1_data     : std_logic_vector(data_width-1 downto 0);
  signal rf_wp_data      : std_logic_vector(data_width-1 downto 0);
  signal rf_wp_addr      : std_logic_vector(3 downto 0);

  
  -- PC signals

  signal pc_pc   : std_logic_vector(addr_width-1 downto 0);

  
  -- compare unit

  signal cmp_z  : std_logic;
  signal cmp_nz : std_logic;
  signal cmp_y  : std_logic_vector(data_width-1 downto 0);


  -- ALU signals

  signal alu_y   : std_logic_vector(data_width-1 downto 0);

  
  -- barrel shifter signals
  
  signal shift_y   : std_logic_vector(data_width-1 downto 0);


  -- instruction decoder
  
  signal idecode_alu_anl             : std_logic;
  signal idecode_pc_inc              : std_logic;
  signal idecode_pc_load             : std_logic;
  signal idecode_dmem_wen            : std_logic;
  signal idecode_rf_wp_en            : std_logic;
  signal idecode_io_rd               : std_logic;
  signal idecode_io_wr               : std_logic;

  
  -- misc signals
  
  signal imm   : std_logic_vector(data_width-1 downto 0);
  signal mem_y : std_logic_vector(data_width-1 downto 0);
  signal bs    : std_logic_vector(0 downto 0);


  -- component decls generated by coregen for block rams
  
  COMPONENT eds_imem
    PORT (
      clka  : IN STD_LOGIC;
      addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
      douta : OUT STD_LOGIC_VECTOR(23 DOWNTO 0)
      );
  END COMPONENT;

  COMPONENT eds_dmem
    PORT (
      clka  : IN STD_LOGIC;
      wea   : IN STD_LOGIC_VECTOR(0 DOWNTO 0);
      addra : IN STD_LOGIC_VECTOR(11 DOWNTO 0);
      dina  : IN STD_LOGIC_VECTOR(15 DOWNTO 0);
      douta : OUT STD_LOGIC_VECTOR(15 DOWNTO 0)
      );
  END COMPONENT;

  
  
begin

  -- instruction memory
  
  --inst_imem : entity work.eds_imem  --(xilinx_bram)
  --  port map (clk   => clk90,
  --            reset => reset,
  --            addr  => pc_pc,
  --            dout  => imem_instr);


  --  data memory

  --bs <= (others =>  idecode_dmem_wen);
  
  --inst_dmem : entity work.eds_dmem  --(xilinx_bram)
  --  port map (reset  => reset,
  --            clk   => clk90,
  --            we     => idecode_dmem_wen, --bs,
  --            addr  => dmem_addr,
  --            din   => rf_rp0_data,
  --            dout  => dmem_dout);
  

  bs <= (others => idecode_dmem_wen);
  
  -- instruction memory
  
  inst_imem : eds_imem 
    port map (clka   => clk90,
              addra  => pc_pc,
              douta  => imem_instr);


  --  data memory

  bs <= (others =>  idecode_dmem_wen);
  
  inst_dmem : eds_dmem 
    port map (clka   => clk,
              wea    => bs,
              addra  => dmem_addr,
              dina   => rf_rp0_data,
              douta  => dmem_dout);


  -- data memory address muxed between immediate in instruction word
  -- and lower 12 bits in read port 0 data
    
  dmem_addr <= imem_instr(11 downto 0) when imem_instr(23) = '1' else
               rf_rp0_data(11 downto 0);


  
  
  --  register file
  
  inst_rf : entity work.ice_rf(behaviour)
    port map (clk      => clk90,
              reset    => reset,
              rp0_addr => imem_instr(15 downto 12),
              rp0_data => rf_rp0_data,
              rp1_addr => imem_instr(11 downto 8),
              rp1_data => rf_rp1_data,
              wp_addr  => rf_wp_addr,
              wp_data  => rf_wp_data,
              wp_en    => idecode_rf_wp_en);


  -- write port address needs to be muxed between DST and SRC0 field
  -- in instruction word

  imm   <= (data_width-1 downto addr_width => imem_instr(addr_width-1)) & imem_instr(addr_width-1 downto 0);
  
  with imem_instr(23) select
    rf_wp_addr <= imem_instr(15 downto 12) when '1',
                  imem_instr(7 downto 4)   when others;

  with imem_instr(22 downto 20) select
    rf_wp_data <= alu_y    when "001",    -- ALU
                  shift_y  when "010",    -- SHIFTER
                  cmp_y    when "011",    -- COMPARE
                  mem_y    when others;   -- MEMORY
  
  with imem_instr(19 downto 16) select
    mem_y <= imm        when "0000",      -- LD   : load immediate to RF
             dmem_dout  when "0001",      -- LDM  : load memory
             io_din     when others;      -- LDIO : load io
             

  -- arithmetic / logic unit
  
  inst_alu : entity work.ice_alu(behaviour)
    port map (a   => rf_rp0_data,
              b   => rf_rp1_data,
              y   => alu_y,
              opc => imem_instr(19 downto 16),
              anl => idecode_alu_anl);


  -- barrel shifter

  inst_shift : entity work.ice_shifter(behaviour)
    port map (a   => rf_rp0_data,
              pos => rf_rp1_data,
              y   => shift_y,
              opc => imem_instr(19 downto 16));


  --  compare unit
  
  inst_cmp : entity work.ice_cmp(behaviour)
    port map (a    => rf_rp0_data,
              b    => rf_rp1_data,
              opc  => imem_instr(19 downto 16),
              lt   => open,
              eq   => open,
              gt   => open,
              z    => cmp_z,
              nz   => cmp_nz, 
              y    => cmp_y);  

  
  -- program counter
  
  inst_pc : entity work.ice_pc(behaviour) 
    port map (clk   => clk,
              reset => reset,
              inc   => idecode_pc_inc,
              load  => idecode_pc_load,
              imm   => imem_instr(addr_width-1 downto 0),
              pc    => pc_pc);

  
  --  instruction decoder

  inst_idecode : entity work.ice_idecode(behaviour)
    port map (imm                 => imem_instr(23),
              grp                 => imem_instr(22 downto 20),
              opc                 => imem_instr(19 downto 16),
              cmp_z               => cmp_z,
              cmp_nz              => cmp_nz,
              pc_load             => idecode_pc_load,
              pc_inc              => idecode_pc_inc,
              alu_anl             => idecode_alu_anl,
              rf_wp_en            => idecode_rf_wp_en,
              dmem_wen            => idecode_dmem_wen,
              io_rd               => idecode_io_rd,
              io_wr               => idecode_io_wr);


  -- misc wiring

  io_addr <= dmem_addr;
  io_dout <= rf_rp0_data;
  io_rd   <= idecode_io_rd;
  io_wr   <= idecode_io_wr;
  pc      <= pc_pc;

end behaviour;
